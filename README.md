# rick_and_morty

Rick and Morty flutter app.

## Getting Started

Архитектура - это о легкости изменяемости и легкости развертнывания приложения, это о независимости
разработки, это об управлении сложностью нашего приложения.

Основные преимущества clean architecture:
- Независимость от фреймворка
    Архитектрура не зависит от существования какой-либо библиотеки. Это позвонляет использовать
    фреймворк в качестве инструмента, вместо того, чтобыы втискивать свою систему в рамки его
    ограничений.
- Независимость от UI
    Пользовательский интерфейс можно легко изменить, не изменяя остальную систему.
- Независимость от БД
- Независимость от какого-либо внешнего сервиса
    По факту наши бизнес правила ничего не знаю о внешнем мире.
- Тестируемость
    Бизнес-правила могут быть протестированы без пользовательского интерфейса, БД, веб-сервера.

Архитектура не опредляет точное количество слоев, она закладывает фундамент. В оригинальной 
диаграмме clean architecture выделается 4 слоя:
1. Entities - сущности - это безнес-логика приложения
2. Use Cases - методы использования или сценарии (так же их называют итеракторами). Эти метода 
организуют поток данных в Entities и обратно. В этом слое находится логика приложения.
3. Interface adapters - набор адаптеров, которые преобразуют данные, полученные из БД или api, в 
формат, удобный для Use Cases. К этим адаптерам принадлежать Presenterы, Controllerы и репозитории.
4. Framework - внешний слой, тут лежит: user interface БД, http client.

Расположим слои по уровням, у нас получится 3 уровня:
1. Presentation Layer (UI, Presenter)
2. Domain Layer (Use Cases, Entities)
3. Data Layer (Repository, Web/DB)

Как происходит взаимодействие всех слоев:
Событие пользователя через UI идет в Presenter, тот передает события в Use Cases, Use Cases делает 
запрос в Repository. Repository получает данные либо с БД, либо с бекенда, Repository создает 
Entities, на основе полученных данных. Entities передает данные в Use Cases, так Use Cases получает 
все нужные ему Entities. Затем применив их и свою логику, получает результат, которые передает 
обратно в Presenter, а тот, в свою очередь, отображает их нашему userу. 

Между слоями есть граница - она представляет собой 2 интерфейса: один для запроса, один для ответа.
Вместо того, чтобы Use Case напрямую зависел от Presenter, что нарушало бы правило зависимостей, он 
зависит от интерфейса на своем уровне, а Presenter должен этот интерфейс реализовать.

Уровень Domain является безопасным центром приложения, который не зависит от других уровней, уровен
Data - это место, где приложение встречается с суровым внешним миром api-интерфейсов и сторонних 
библиотек. Он состоит из низкоуровневых источников данных datasources (RemoteDataSources и 
LocalDataSources). Также из репозитория и моделей. Мы начали со слоя Domain не спроста - он самый 
независимый из всех слоев.